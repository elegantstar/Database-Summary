# Index

## 보조 기억 장치

- `데이터베이스`는 `File`들의 집합으로 저장되며, 각 File은 일반적으로 동일한 유형의 `Record`들의 모임으로 이루어진다. 각 Record는 연관된 Filed들의 모임이며, 동일한 개수 및 일정한 크기를 갖는 Field들로 이루어진 `고정 길이 레코드`, 각 레코드마다 서로 다른 Field의 개수를 갖거나 각 Field의 길이가 가변적인 `가변 길이 레코드`로 구분된다.
- File들은 일반적으로 `Disk`와 같은 `보조 기억 장치`에 저장된다. 원하는 데이터를 검색하기 위해서는, DBMS는 디스크 상의 데이터베이스로부터 원하는 데이터를 포함하고 있는 `Block`을 읽어서 `주기억 장치`로 가져와야 한다.
- 보조 기억 장치에서 주기억 장치로 이동하는 데이터의 단위는 `블록(주기억 장치에서는 페이지)`이다. 블록의 크기는 운영체제에 따라 다르지만, 전형적인 크기는 4,096byte이다. 각 File은 고정된 크기의 블록들로 나뉘어 저장된다.
- 디스크에서 임의의 블록을 읽어오거나 기록하는데 걸리는 시간은 `Seek Time(탐구 시간)`, `Rotational Delay(회전 지연 시간)`, `Transfer Time(전송 시간)`의 합이다.

  - **탐구 시간(Seek Time)** : 디스크 헤드가 원하는 실린더 위에 놓일 때까지 걸리는 시간
  - **회전 지연 시간(Rotational Delay)** : 원하는 블록이 디스크 헤드 밑에 올 때까지 걸리는 시간
  - **전송 시간(Transfer Time)** : 블록을 주기억 장치로 전송하는데 걸리는 시간

- 디스크 접근에 소요되는 시간을 줄이기 위해서는 `평균 회전 지연 시간`을 줄이고, `블록 전송 횟수`를 줄이는 것이 관건이다.
- 블록의 크기는 일반적으로 레코드 크기보다 훨씬 크기 때문에 많은 레코드들이 한 블록에 저장된다. 그러나 레코드 길이가 블록 크기를 초과하는 경우, 한 레코드를 두 개 이상의 블록에 걸쳐서 저장하는데 이러한 레코드를 `Spanned Record(신장된 레코드)`라고 한다.
- `Fill Factor(채우기 인수)`는 각 블록의 레코드를 채우는 공간의 비율을 말하는데, Fill Factor에 따라 블록에 레코드를 가득 채우지 않고 빈 공간을 남겨 두면 추가적인 레코드 삽입에 대응할 수 있다.

<br>

## Heap File(비순서 파일) vs Sequential File(순차 파일)

### Heap File

`Heap File(비순서 파일)`은 가장 단순한 파일 조직으로, **레코드들이 삽입된 순서대로 파일에 저장**된다. 일반적으로 새로 삽입되는 레코드는 파일의 가장 끝에 삽입되며, 레코드를 삭제하는 경우 삭제된 레코드가 차지하던 공간을 재사용하지 않는다. 따라서 삽입은 쉬우나 레코드들의 순서는 존재하지 않기 때문에 원하는 레코드를 찾기 위해서는 모든 레코드를 순차적으로 접근해야 한다.  
또한, 시간이 지날수록 삭제된 레코드들이 차지했던 공간이 재사용되지 않아 파일의 크기가 증가하게 된다. 데이터 조회 시, 이러한 빈 공간도 탐색하기 때문에 조회 시간이 길어지게 된다. 따라서 Heap File의 성능 유지를 위해서는 주기적으로 재조직할 필요가 있다.

Heap File은 릴레이션에 데이터를 한꺼번에 적재할 때(Bulk Loading), 릴레이션의 블록 수가 적을 때, 모든 튜플들이 검색 위주로 사용될 때 주로 사용된다. 정리하면, **Heap File은 레코드 삽입이 쉽고, Query에서 레코드 순서에 관계 없이 전체 레코드를 조회하는 경우에 효율적**이다. 그러나 **특정 레코드를 검색하거나 범위 검색을 하는 등 많은 경우에 모든 레코드들에 접근해야만 하는 비효율적인 구조**를 가지고 있다.

### Sequential File

`Sequential File(순차 파일)`은 **레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 파일**이다. 레코드들이 일반적으로 레코드의 `Search Key(탐색 키)` 값의 순서에 따라 저장된다. 탐색키는 **순차 파일을 정렬하는데 사용되는 필드**를 의미하며, 당연하게도 레코드들에 순차 접근하는 경우에 적합하다. 이런 탐색키 값은 오름차순으로 정렬되어 있기 때문에 특정 레코드 탐색 시 `Binary Search(이진 탐색)`을 활용할 수 있어 순차 탐색 보다 탐색 시간을 줄일 수 있다.  
순차 파일에서 삽입 연산을 진행할 때에는 레코드의 순서를 고려해야 하기 때문에 시간이 많이 걸릴 수 있다. 삽입할 위치가 비어 있는 경우 삽입을 진행할 수 있지만, 빈 공간이 없는 경우 삽입할 레코드를 `Overflow 블록`에 넣거나 다음 블록으로 이동하는 등의 작업을 수행한다. 삭제의 경우 비순서 파일과 마찬가지로 삭제된 레코드의 공간을 빈 공간으로 남겨두기 때문에 주기적인 재조직이 필요하다.

Primary Index가 순차 파일에 정의되지 않는 한 순차 파일은 거의 사용되지 않는다. **Sequential File은 Search Key(탐색 키)를 기반으로 탐색하는 경우에 효율적**이다.

<hr>

## 데이터베이스에서 Index

`Index`는 의미 그대로 서적의 가장 뒤쪽에 수록되어 특정 주제가 실린 페이지를 쉽게 찾도록 도와주는 색인과 같은 기능을 한다. 따라서 데이터베이스에서의 Index는 어떤 일정한 순서에 따라 데이터가 저장되어 있는 주소를 기록하고 있는 색인으로, 각 레코드는 서적의 특정 내용, 레코드가 저장된 주소값은 해당 주제가 실린 페이지로 비유할 수 있다.  
DBMS가 데이터베이스 릴레이션 내의 모든 데이터를 탐색하는 것은 많은 시간이 소요되지만, **<탐색 키, 레코드에 대한 포인터>로써 key-value 형식의 index를 활용한다면 특정 레코드들을 빠르게 찾을 수 있다**. 따라서 **index는 임의 접근이 필요한 경우에 효율적**이다. 여기서 탐색 키는 index가 정의된 field를 말한다.

**DBMS의 index는 항상 정렬된 상태를 유지하기 때문에 특정 데이터를 탐색하는 것은 빠르지만, 새로운 레코드를 추가하거나 삭제 및 수정을 하는 경우에는 Query 실행 속도가 느려진다. 즉, DBMS에서 index는 데이터 갱신(삽입, 삭제, 수정) 성능을 희생시켜 탐색 선응을 대폭 향상시키는 기능**이다. 단, index가 탐색에 효과적이라고 하여 모든 attribute에 index를 생성하는 것은 데이터 갱신 성능을 저해하고, 불필요한 저장 공간을 사용하게 되는 것이기에 index를 생성할 attribute를 선정하는 것도 중요하다.

### Index 저장 알고리즘, B+-Tree Index Algorithm

**DBMS에서 index를 구현하고 있는 알고리즘은 `B+-Tree` 알고리즘**이다. B+-Tree index는 `Column`의 값을 변형하지 않고, 원래 값을 이용하여 indexing 한다. 원래 값을 변형하지 않는다고 했지만, 실제로는 값의 앞 부분만 잘라서 관리한다. B-Tree는 `Balanced Tree`로, `Root Node`, `Branch Node`, `Leaf Node`가 존재하며, 이 중 최하위에 존재하는 Leaf Node에는 실제 데이터 레코드를 검색할 수 있도록 `Primary key`가 저장되어 있다.

### Hash Index Algorithm

**`Hash Index Algorithm`은 Column의 값으로 `Hash value`를 계산해서 indexing 하는 알고리즘으로 매우 빠른 검색을 지원**한다. 그러나 원래 값을 변형하여 indexing 하므로, 특정 문자로 시작하는 값으로 검색 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 하는 경우 Hash index를 사용할 수 없다. Hash index는 `Hash Table`의 특성을 닮아 있기에 Hash value의 범위에 따라 성능이 달라진다. Hash value의 범위가 넓은 경우는 `bucket`의 크기가 커져서 공간의 낭비가 커지고, Hash value의 범위가 좁은 경우에는 `Hash Collision` 빈도가 증가하기 때문에 Hash index의 메리트가 사라지는 단점을 갖는다. 이러한 Hash index는 메모리 기반의 데이터베이스에서 주로 사용된다.

### Index 관리에 B+-Tree를 사용하는 이유

데이터에 접근하는 `Time Complexity`만 놓고 생각해 본다면 Time Complexity가 O(1)인 Hash Table이 더 효율적인 것처럼 보인다. 그러나 실제로 데이터를 조회하는 SELECT Query 조건에는 부등호(< >) 연산도 포함된다. Hash Table이 등호(=) 연산에서 위력을 발휘할지라도, 부등호 연산을 수행해야 할 경우에는 Hash Function에 의해 값이 변형되므로 연산 자체가 불가능해진다. 따라서 동등 연산에 특화된 Hash Table은 데이터베이스의 자료구조로 적합하지 않다. 이러한 이유로 데이터베이스의 indexing에는 기존 값을 변형하지 않는 B+-Tree를 사용한다.

<br>

## Primary Index vs Secondary Index
